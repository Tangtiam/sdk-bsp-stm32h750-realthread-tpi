# MCF API 接口说明

本章节主要介绍 MCF 软件包对外提供接口功能和使用方式。

## MCF 初始化

```c
int mcf_init(uint8_t id);
```

该接口用于初始化 MCF 功能。

| 参数      | 描述                     |
| :-------- | :----------------------- |
| id | 当前设备 ID       |
| **返回**  | **描述**                 |
|    0   |  初始化成功               |
| != 0    | 初始化失败               |

### MCF 启动

```c
void mcf_init(void);
```

该接口用于启动 MCF 功能，开始数据接收和处理。

### 链路层 UART 串口对象注册

```c
int mcf_link_uart_register(uint8_t port_id, const char *dev_name, void *user_data);
```

该接口用于 MCF 链路层串口对象注册，注册完成可通过该链路层对象进行数据通讯。

| 参数      | 描述                     |
| :-------- | :----------------------- |
| port_id | 链路层接口 ID       |
| dev_name | 串口设备名称       |
| user_data | 用户数据          |
| **返回**  | **描述**                   |
|    0   |  UART 串口对象注册成功          |
| != 0    | UATR 串口对象注册失败          |

###  链路层功能控制

```c
int mcf_link_control(uint8_t port_id, int cmd, void *arg);
```

该接口用于控制 MCF 链路层设备功能，如是否需要 CRC16 数据校验等。

| 参数      | 描述                     |
| :-------- | :----------------------- |
| port_id | 链路层接口 ID       |
| cmd | 功能控制命令值           |
| arg | 功能控制参数             |
| **返回**  | **描述**                   |
|    0   |  执行控制命令成功               |
| != 0    | 执行控制命令失败               |

### 链路层添加 ARP 列表

```c
int mcf_link_arp_add(uint8_t port_id, uint8_t dev_id);
```

该接口用于添加和更新链路层端口和设备对应表，该表主要用于链路层数据发送时查询数据发送端口和发送设备。

| 参数      | 描述                     |
| :-------- | :----------------------- |
| port_id | 链路层接口 ID       |
| dev_id | 设备 ID             |
| **返回**  | **描述**                 |
|    0    | 添加 ARP 列表成功       |
| != 0    | 添加 ARP 列表失败       |

### 链路层删除 ARP 列表

```c
int mcf_link_arp_delete(uint8_t port_id, uint8_t dev_id);
```

该接口用于删除和更新链路层端口和设备对应表。

| 参数      | 描述                     |
| :-------- | :----------------------- |
| port_id | 链路层接口 ID       |
| dev_id | 设备 ID             |
| **返回**  | **描述**                 |
|    0    | 删除 ARP 列表成功       |
| != 0    | 删除 ARP 列表失败       |

## 创建 D2D 协议会话

```c
int mcf_d2d_open(uint8_t dst_id);
```

 MCF D2D（Deivce To Device）协议数据传输基于会话模式，类似于 HTTP 协议，数据的请求和响应为一个完成的会话，会话使用完成需关闭之后重新创建。

该接口用于通过目标 ID 创建一个 D2D 协议会话。

| 参数      | 描述                     |
| :-------- | :----------------------- |
| dst_id | 数据发送目标 ID       |
| **返回**  | **描述**                 |
|    0    | 创建的会话 ID，即 D2D 数据包 ID   |
| != 0    | 创建会话失败        |

当入参 dst_id 不同是，当前会话功能有所不同，如下所示：

| dst_id  | 功能                                                         |
| ------- | ------------------------------------------------------------ |
| 1 - 253 | 正常数据串口会话功能， 会话 ID 大于 0，发送和接收指定会话 ID 的数据包 |
| 254     | 接收数据模式，该模式接收所有会话 ID 的数据包，不支持发送数据包 |
| 255     | 广播数据发送模式，该模式发送数据到所有的连接设备，不支持接收数据包 |

## 发送 D2D 协议数据

```c
int mcf_d2d_send(int sid, struct mcf_pkt *pkt, int32_t timeout);
```

该接口用于在指定超时时间内发送传入的包数据。

| 参数      | 描述                     |
| :-------- | :----------------------- |
| sid     | 会话 ID                  |
| pkt     | 需要发送的数据包对象       |
| timeout | 发送数据超时时间          |
| **返回**  | **描述**                 |
|    0    | 发送包数据成功       |
| != 0    | 发送包数据失败       |

## 接收 D2D 协议数据

```c
int mcf_d2d_recv(int sid, struct mcf_pkt *pkt, int32_t timeout);
```

该接口用于在指定超时时间内接收包数据。

| 参数      | 描述                     |
| :-------- | :----------------------- |
| sid     | 会话 ID                  |
| pkt     | 接收数据的包对象       |
| timeout | 接收数据超时时间          |
| **返回**  | **描述**                 |
|    0    | 接收包数据成功       |
| != 0    | 接收包数据失败       |

## 关闭 D2D 协议会话

```c
int mcf_d2d_close(int sid);
```

该接口用于关闭 D2D 协议会话。

| 参数      | 描述                     |
| :-------- | :----------------------- |
| sid     | 会话 ID                  |
| **返回**  | **描述**                 |
|    0    | 关闭会话成功       |
| != 0    | 关闭会话失败       |

## 注册请求自动响应回调函数

```c
int mcf_req_exec_fn_register(mcf_req_exec_fn req_fn);
```

该接口用于请求自动响应模式（开启 MCF_USING_REQ_EXEC ）下，注册请求自动执行回调函数。

| 参数      | 描述                     |
| :-------- | :----------------------- |
| req_fn     | 请求自动执行回调函数                  |
| **返回**  | **描述**                 |
|    0    | 回调注册成功       |
| != 0    | 回调注册失败       |

## 静态创建包对象

```c
struct mcf_pkt *mcf_pkt_make(struct mcf_pkt *pkt, void *buf, size_t len, size_t size);
```

该接口用于动态创建应用层包对象。

| 参数      | 描述                     |
| :-------- | :----------------------- |
| pkt      | 包对象指针                  |
| buf      | 包对象中数据缓冲器指针        |
| len      | 包对象中数据缓冲器当前使用长度  |
| size      | 包对象中数据缓冲器最大使用长度  |
| **返回**  | **描述**                 |
| != RT_NULL    | 静态创建包对象成功       |
|  = RT_NULL    | 静态创建包对象失败       |


## 动态创建包对象

```c
struct mcf_pkt *mcf_pkt_alloc(int sid, size_t size);
```

该接口用于动态创建应用层包对象。

| 参数      | 描述                     |
| :-------- | :----------------------- |
| sid     | 会话 ID                  |
| size     | 最大接收数据长度           |
| **返回**  | **描述**                 |
| != RT_NULL    | 创建包对象成功       |
|  = RT_NULL    | 创建包对象失败       |

## 释放动态包对象

```c
int mcf_pkt_free(struct mcf_pkt *pkt);
```

该接口用于释放动态创建的包对象。

| 参数      | 描述                     |
| :-------- | :----------------------- |
| pkt      | 包对象指针                  |
| **返回**  | **描述**                 |
|    0    | 释放包对象成功       |
|  = 0    | 释放包对象失败       |

## 设置包对象信息

```c
struct mcf_pkt *mcf_pkt_info_set(struct mcf_pkt *pkt, uint8_t type, uint16_t flag);
```

该接口用于设置包对象信息，常用于数据发送命令之前，设置发包类型和响应、ACK 等功能。

| 参数      | 描述                     |
| :-------- | :----------------------- |
| pkt      | 包对象指针                  |
| type      | 设置的包类型                  |
| flag      | 设置的包状态                 |
| **返回**  | **描述**                 |
|    != RT_NULL    | 设置成功，返回包对象指针 |
|       RT_NULL    | 设置失败              |

- 包类型包括两种：MCF_PKT_TYPE_REQ（请求包）、MCF_PKT_TYPE_RSP（响应包）；
- 包状态包含两种：MCF_PKT_FLAG_NEED_ACK（需要 ACK 回应）、MCF_PKT_FLAG_NEED_RSP（需要请求响应）。

## 获取包对象信息

```c
int mcf_pkt_info_get(struct mcf_pkt *pkt, uint8_t *type, uint16_t *flag);
```

该接口用于获取当前包对象类型和状态等信息。

| 参数      | 描述                     |
| :-------- | :----------------------- |
| pkt       | 包对象指针                  |
| type      | 获取的包类型                |
| flag      | 获取的包状态                |
| **返回**  | **描述**                 |
|    0   | 获取包对象状态成功      |
| != 0   | 获取包对象状态失败      |
